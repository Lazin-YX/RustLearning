# 基本概念
## 默认语义
Rust变量默认不可变; 除基本类型外，Rust默认使用移动语义
```rust
//i为不可变变量(const int_32)
let i: i32 = 1;
//复制i
let j = i;
//s通过mut声明为可变变量
let mut s: String = "str".to_string();
//String不是基础类型，语义为移动
let s1 = s;
```
## 所有权与借用
所有权的概念
> 1. Rust 中每一个值都被一个变量所拥有，该变量被称为值的所有者
> 2. 一个值同时只能被一个变量所拥有，或者说一个值只能拥有一个所有者
> 3. 当所有者（变量）离开作用域范围时，这个值将被丢弃(drop)  
> 　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　-- Rust圣经

借用的概念
> 借用即借取变量的引用

借用几乎就是指针，与指针的区别在于它仅仅借用了资源的所有权  
借用分为读借用`&`与读写借用`&mut`, 一份资源可以同时拥有多个读借用**或**一个读写借用  
一份资源被读借用走时，变量本身也可以视为一个读借用; 一份资源被读写借用走时，它的所有权被彻底借走了，变量本身也无法读写这份资源, 直到所有权归还  
借用是一个类型, 自身也可以区分可变/不可变
```rust
//注意区分顶层mut与底层mut
//Rust所有变量(借用本身也是一个变量)必须初始化后才能使用
let mut s: &mut String;
```
> Tips: Rust借用与C++引用有很多相似的地方, 原因在于两者都实现了自动解引用, 但一定注意Rust不总是自动解引用; 借用就是一个(胖)指针，不要与引用搞混

## 基本类型
整数默认类型: i32  
整数溢出: Debug模式下报错, Release模式按补码循环溢出  
整数除以0会造成panic
移位运算会检查溢出, 移位超出位数范围会报错
> 问题: 这种检查有没有运行时开销? 

浮点数默认类型: f64  
浮点数没有定义`=`(std::cmp::Eq), 不能用于HashMap Key  
浮点数除以0会返回特殊值`Infinity`或`NaN`  
可以使用`is_infinite()`和`is_nan()`方法检查

单元类型, unit, 表现为一个空元组`()`, 不占用内存  
布尔类型: bool, `true/false`, 固定1byte(8bit)  
字符类型: char, 表现为`'c'`, 固定4byte(32bit), Unicode编码  
字符串类型: str, 单字符(char)的字节数可变,为1~4byte(8~32bit), UTF-8编码, str通常需要通过引用使用(因为它本身长度不固定), 复合类型章节会对字符串做详细介绍

## 语句与表达式
区别: 表达式有值, 语句没有  
在表达式结尾添加`;`可以将表达式转换为语句

Rust几乎一切均为表达式，包括`if`, `match`, `loop`; `for`/`while`/`return`也是表达式，但只能返回`()`(这三个关键字虽然能作为表达式,但其值无意义)  
`{}`也是表达式, 其值为块内最后一个表达式的值, 若块由语句结尾，则隐式添加`()`作为返回值  
例外: 以下关键字必须是语句  
- let

## 函数
引用自Rust圣经
![img.png](img1-func.png)
函数定义中每个参数必须标注类型,只有在返回值为`()`时可省略返回值
函数也是表达式, 函数的return语句或最后一行表达式(若分支的最后一行为非return语句,则隐式添加表达式`()`作为返回值)
发散函数: 返回值类型为`!`, 表示该函数永不返回