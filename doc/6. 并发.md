# 并发
## 线程
`use std::thread;`  
创建新线程: `thread::spawn(|| {}) -> JoinHandle<>`  
`thread::sleep(std::time::Duration)`用于让线程阻塞指定时长  
主线程结束时, 新线程也会终止而不会等待结束  
调用`JoinHandle<T>`的方法`join`会阻塞当前线程直到方法的线程结束  
新线程无法借用主线程中的数据, 因为Rust无法推断新线程会借用多久  
## move闭包
在闭包参数列表`||`前加`move`关键字强制闭包获取其使用的环境值的所有权  
可用于在新线程中使用原本在主线程中的数据  
## 线程间通信
`use std::sync::mpsc;`  
创建MPSC通道: `mpsc::channel() -> (Sender<T>, Receiver<T>)`  
mpsc为多发送者, 单接收者, 可以调用`Sender<T>`的方法`clone`获得多个发送者  
发送端与接受段任意一端被丢弃, 通道关闭  
`Sender<T>`的方法`send(T) -> Result<(), SendError<T>>`会向通道发送一个值以及其所有权, 若通道已关闭返回Err, 注意: send会获取T的所有权  
`Receiver<T>`的方法`recv() -> Result<T, RecvError>`会阻塞线程直到通道收到值, 若通道已关闭返回Err  
`Receiver<T>`还有`try_recv`, `recv_timeout`等方法  
`recv`可用作迭代器, 每次返回接收到的值, 通道关闭, 迭代器结束  
## 内存共享
### 互斥器(mutex)
`use std::sync::Mutex`  
`Mutex<T>`表示对实例T创建互斥器  
通过互斥器调用实例前必须使用`lock() -> LockResult<MutexGuard<T>>`上锁, 调用结束后(可自动)解锁  
`lock`方法阻塞线程直到获得锁, 若锁在其他线程锁定且被panic, 则调用失败, 返回Er--?  
若调用成功, 则返回一个智能指针`MutexGuard<T>`, 这个智能指针Drop不会释放数据, 而是释放锁  
`Mutex<T>`与`RefCell<T>`都提供了内部可变性, 都有造成死锁的风险  
## Arc\<T\>
`Arc<T>`原子引用计数智能指针, 可用于多线程并发安全的资源共享  
`Rc<T>`不保证引用计数操作的原子性, 故无法线程安全的管理资源, 只能在单线程内进行资源共享  
提供原子性存在性能惩罚, 故非必要不要引入原子性  


