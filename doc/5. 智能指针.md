# 智能指针
## 实现
智能指针是一类实现了`Deref`与`Drop`trait的数据结构, 通常为结构体 eg. `String`, `Vec<T>`  
通常, 智能指针拥有它们指向的数据, 而普通引用是一类只借用数据的指针  
`Deref/DerefMut`trait允许智能指针被当作引用, `Drop`trait实现了智能指针离开作用域时堆数据的清除  
## Deref/DerefMut trait
`Deref/DerefMut` trait 重载了解引用运算符`*`, 使得结构体可以被视为常规引用, eg.  
```rust
impl<T> Deref for MyBox<T> {
    type Target = T;
    
    fn deref(&self) -> &T;
}
```
使用`*`调用实现了`Deref` trait的结构体时, rust会先调`deref(&self)`方法, 即:  
`*MyBox<T>`等价于`*MyBox<T>.deref()`  
### 解引用强制转换(隐式转换)
将**引用**作为参数传递给函数或方法时, 若形参与实参类型不匹配时, 就会反复尝试解引用强制转换(隐式转换)直到类型匹配  
解引用强制转换发生在编译期, 没有运行时损耗  
解引用强制转换只能工作在实现了`Deref/DerefMut`trait的类型上, 将一种类型隐式转换为另一种类型的引用  
当对实现了`Deref`trait的类型`a`使用解引用运算符时, 编译器会将它自动替换为`a.deref()`, 即: `*a`->`*a.deref()`  
可变引用可以转换为不可变引用, 但不可变引用无法转变为可变引用  
如`&String`可以解引用强制转换为`&str`, 变换路径: `&String`->`&*String`->`&*String.deref()`->`&*(&str)`->`&str`  
## Drop trait
`Drop`trait 用于在实例离开作用域时自动清理内存或资源, 编译器会在对应的位置插入drop相关代码  
`Drop`trait需要实现`drop(&mut self)`方法, 该方法不能显示调用, 如需提前drop, 可以调用`std::mem::drop`函数  
## Box\<T\>
`Box<T>`实例将T存放到堆上, 栈上保留一个指针
没有额外的性能损失, 同时也没有额外的功能  
用途:  
1. 用于在堆上存储数据  
2. 为在编译期无法确定大小的数据提供确定的大小(`usize`)的调用方式, eg.  
```rust
enum List {
    Cons(u32, Box<List>),
    Nil,
}
```
## Rc\<T\>
`Rc<T>`引用计数智能指针用于单线程的资源共享(只读)  
`Rc::clone(&rc)`不会进行克隆, 而是增加强引用计数  
每个所有者都拥有对`Rc<T>`的所有权而不是借用, 即多所有权  
`Rc::strong_count(&rc)`获得强引用计数  
如果不想获得所有权, 应使用`Rc::downgrade(&rc)`获得弱引用`Weak<T>`  
`Rc::weak_count(&rc)`获得弱引用计数, 弱引用不影响对象释放  
调用`Weak<T>`的`upgrade`方法获得`Option<Rc<T>>`  
## RefCell\<T\>
`RefCell<T>`在运行时检查借用规则, 如果违反规则则panic  
`RefCell<T>`只能用于单线程场景, 不允许对象拥有多个所有者, 与`Box<T>`类似  
由于`RefCell<T>`在运行时执行可变借用检查, 所以可以在`RefCell<T>`自身是不可变的情况下修改其内部的值(**内部可变性**)  
`RefCell<T>`的`borrow`方法返回`Ref<T>`, 可被当作`T`的不可变引用(通过`Deref`trait)  
`RefCell<T>`的`borrow_mut`方法返回`RefMut<T>`, 可被当作`T`的可变引用, 即使`RefCell<T>`本身是不可变的  
`RefCell<T>`通过记录当前活动的`Ref<T>`与`RefMut<T>`数来维护借用规则, 从而实现运行时检查  
在运行时捕获错误会延后错误发现的时机, 并且会造成性能惩罚, 但这使结构在只允许不可变值的上下文中实现对自身的修改
通过将`RefCell<T>`与`Rc<T>`结合, 实现在单线程, 多所有者(只读)的情况下修改内部的值`Rc::new(RefCell::new(x))`, 需注意内存泄露  
### 内部可变性
对于编译期检查的借用, 不能可变的借用一个不可变的值, eg:  
```rust
let x = 5;
let y = &mut x; //error[E0596]: cannot borrow `x` as mutable, as it is not declared as mutable 
```
付出少量代价, 通过运行时检查的借用, 如`RefCell<T>`即可实现内部可变性, 通过不可变借用实现值的可变  
