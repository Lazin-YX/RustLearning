# 复合类型
## 数组与向量
数组array固定长度, 向量vector可变长度  
`let a : [i32; 5] = [0; 5]`  
通过`[i; n]`的形式创建数组时, i的类型必须实现copy triat 或调用from_fn, 如下:  
`let a: [String; 5] = std::array::from_fn(|_i| String::from("a"));`  

新建vector方法:  
    `let v: Vec<i32> = Vec::new();`  
    `let v : Vec<i32> = vec![1,2,3];`  
    `let v: Vec<i32> = vec![0; 5]`

使用索引读取array或vector时, 若索引的元素不存在时会panic    
可以使用`.get(index)`或`.get_mut(index)`安全的替代索引  

## 字符串
Rust内置字符串类型: str  
String由标准库提供, 本质为Vec<u8>, 切片slice本质为 &str  
String与slice都是UTF-8编码, &String可以被解引用强制转换为&str(通过Deref trait), 故参数为&str的函数可以同时接受&String与slice  
字符串为UTF-8编码, 所以String不允许索引, 可以切片如`&str[0..1]`, 请注意这是**高危操作**, 若切片没有切到字符边界上, 会造成panic  
可以使用`.get(range)`或`.get_mut(range)`安全的替代切片

新建字符串方法:  
    `let mut s = String::new();`  
    `let mut s = String::from("abc")`  
    `let mut s = "abc".to_string()`  
任何实现了Display trait的类型均可以使用`to_string`方法  

附加字符串: push与push_str  
push_str(&str)接受slice, 可以同时添加多个字符  
push(char)接受char字符, 一次只能添加一个字符  
insert与insert_str同上  

拼接字符串: +/+=运算符与format宏  
`let str1 += &str2`  
`+=`运算符不能拼接  
`let str3: String = str1 +"-" + &str2`  
str1的所有权将会被移动到str3, str1在语句后失效, +后必须为引用  
`let str3 = format!("{}-{}", str1, str2);`  
format!与print!原理相同, 区别在于print!将输出打印, format!将输出作为String返回  

遍历字符串: chars与bytes:
返回迭代器, `.chars()`将字符串按char分解, `.bytes()`将字符串按字节分解

##哈希map
哈希map不在std prelude中, 需要引入:  
`use std::collections::HashMap;`  



