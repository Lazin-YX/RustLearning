# unsafe代码
Rust代码必须通过保守的策略保证内存安全, 可以在`usafe{}`代码块内部绕过以下5点限制:  
1. 解引用裸指针
2. 调用不安全的函数或方法
3. 访问或修改可变静态变量
4. 实现不安全trait  
5. 访问union的字段  
`unsafe`代码块并不会关闭借用检查器, 这保证了不安全代码块内也有某种程度的安全
## 解引用裸指针
裸指针分为可变与不可变: `*const T`与`*mut T`  
注意`*`也是类型名称的一部分  
裸指针允许忽略借用规则, 可以同时拥有多个可变/不可变的指向相同位置的指针  
裸指针可以为空, 也不保证一定会指向有效内存  
裸指针不能实现任何自动清理功能  
裸指针可以在安全代码中创建, 只是必须在`unsafe`代码块中解引用  
## 调用不安全的函数或方法
必须在`unsafe`代码块中使用`unsafe`函数  
使用`extern`关键字声明与实现和其他语言的接口  
```rust
//声明C语言函数
extern "C" {
    fn abs(input: i32) -> i32;
}
//创建一个C语言接口
#[no_mangle]
pub extern "C" fn call_from_c() {
    //your rust program
}
```
## 访问或修改可变静态变量
全局变量又称静态变量, 关键字`static`, 引用类型的静态变量必须拥有`'static`声明周期  
常量`const`在编译期被硬编码到代码内, 静态变量的值则有一个固定的内存地址  
静态变量是可变的, 即`static mut`; 访问不可变静态变量是安全的, 访问与修改可变静态变量都是不安全的  
访问与修改可变静态变量都是非原子的, 线程不安全  
## 实现不安全的trait
当trait中有至少一个方法存在编译器无法验证的不变式(invariant)时trait就是不安全的  
## 访问union中的字段
`union`主要用于与C代码交互, 访问联合体的字段是不安全的  
