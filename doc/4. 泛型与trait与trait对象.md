# 泛型/trait/trait对象
## 泛型与trait
trait约束泛型会造成依赖, trait约束另一个trait并不会造成依赖(trait无法实现其他trait), eg:  
```rust
fn function<T: Clone>(t: T) {} //泛型T依赖Clone trait
trait Subtrait: Supertrait {} //Subtrait并不依赖Supertrait
trait Subtrait where Self: Supertrait {} //与上一行等价, 能看到Supertrait是约束到实现了Subtrait的类型Self上的
``` 
trait约束要求实现了该trait的类型必须实现约束的trait  
trait参数的本质是泛型, 即所有满足该trait的泛型类型T  
可以通过泛型同时为多个类型实现方法与关联函数  
### 自动trait
如果一个类型的所有成员均实现了一个自动trait, 则该类型自动实现该trait  
自动trait一定是标记trait(没有成员的trait), 标记trait不一定是自动trait  
### 不安全trait
标记为不安全的trait表明实现该trait可能需要不安全的代码  
`Send`与`Sync`被标记为不安全&&自动trait  
```rust
// implemented for types which are safe to send between threads
unsafe auto trait Send {}
// implemented for types whose references are safe to send between threads
unsafe auto trait Sync {}
```
## 泛型覆盖实现
为泛型实现trait, 可以一次性为所有满足trait约束的类型实现该trait  
不同于默认实现, 泛型覆盖实现不能被重写(重写相当于重复实现)  
## 关联类型type
当每个类型只应有trait的一个实现时, 使用关联类型`type`  
当每个类型可能有trait的多个实现时, 使用范型参数`<T>`  
## trait 对象
`Box<dyn trait>`类似这样的类型叫做trait对象  
Rust在编译期只保证trait对象的实例类型实现了trait对象的trait而无需知道具体类型  
trait对象用于对通用行为进行抽象  
trait对象执行动态分发, 即在运行时才决定调用的方法  
只有类型安全的trait才可以构成trait对象, 其规则为:  
1. 返回值类型不为Self  
2. 方法没有任何泛型类型参数  
因为trait对象会抹去trait对象的原始类型, 所以无法得知Self与泛型参数的类型  




